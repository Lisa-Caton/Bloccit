class PostsController < ApplicationController
  def index
    @posts = Post.all
    # we declare an instance variable @posts and assign it a collection of Post objects using the all method provided by ActiveRecord.
      # all returns a collection of Post objects.
     @posts.each_with_index do |post, id|
       if id % 5 == 0
         post.title = "SPAM"
       end
     end
  end

  # def show
  # we find the post that corresponds to the id in the params that was passed to  show and assign it to @post. Unlike in the index method, in the show method, we populate an instance variable with a single post, rather than a collection of posts.
  def show
    @post = Post.find(params[:id])
    # we find the post that corresponds to the id in the params that was passed to 'show' and assign it to @post. Unlike in the 'index' method, in the 'show' method, we populate an instance variable with a single post, rather than a collection of posts
  end

  def new
    @post = Post.new
  end


  def create
    @post = Post.new
      # we call Post.new to create a new instance of Post
    @post.title = params[:post][:title]
    @post.body = params[:post][:body]
    if @post.save
      # if we successfully save Post to the database, we display a success message using flash[:notice] and redirect the user to the route generated by @post. Redirecting to @post will direct the user to the posts show view

      # we assign a value to flash[:notice]. The flash hash provides a way to pass temporary values between actions. Any value placed in flash will be available in the next action and then deleted
      flash[:notice] = "Post was saved."
      redirect_to @post
    else
      # if we do not successfully save Post to the database, we display an error message and render the new view again
        #When the user clicks Save, the create method is called. create either updates the database with the save method, or returns an error. Unlike new, create does not have a corresponding view. create works behind the scenes to collect the data submitted by the user and update the database. create is a POST action
      flash.now[:alert] = "There was an error saving the post. Please try again."
      render :new
    end
  end
end

  # Slack help -- Kolby
  # So the new action works with the create action and the same for edit & update. Create and update don't need their own views because they work behind-the-scenes. You can see that `@post = Post.new` or something similar to that (inside of the new action), so when the form gets submitted, it calls that `Post.new` which then calls the create action automagically. A lot of things in rails are considered "magic" since the way everything works isn't explicitly traced somewhere. Same wiith edit/update. So your edit.html.erb view will look at the edit action in your controller which probably will have something like `@post = Post.find(params[:id])`, and since you're in the edit view & action, when the form gets submitted, it will automagically go to the update action.

  # "In terms of the folder structure, there's definitely a lot. It's really just something that you'll begin to memorize by doing it so often. A lot of them will very rarely be used too so only a select number will be very frequently used. So, you're going to be inside of the `app` directory most of the time which contains your model, controller, and view files directories/files. The `db` directory is pretty self-explanatory, holds everything regarding the database. Other than that there's really  just the `config` directory which contains all of your app's configurations such as the routes.rb file, where you'll be pretty often, adding/changing routes.""
